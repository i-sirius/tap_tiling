<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <title>–°–≤—ñ—Ç–ª–æ—Ç–∏—Ü—è–ª–∫–∞ (HTML+JS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <style>
    :root {
      --cell: 100px;       /* —Ä–æ–∑–º—ñ—Ä –∫–ª—ñ—Ç–∏–Ω–∫–∏ */
      --panel-w: 260px;    /* —à–∏—Ä–∏–Ω–∞ –ø—Ä–∞–≤–æ—ó –ø–∞–Ω–µ–ª—ñ */
      --field-gap-bottom: 60px; /* –º—ñ—Å—Ü–µ –ø—ñ–¥ –ø–æ–ª–µ–º –¥–ª—è —Ç–µ–∫—Å—Ç—É */
      --bg: #c8c8c8;
      --panel-bg: #e6e6e6;
      --grid: #000;
      --on: #085850;   /* –±—ñ—Ä—é–∑–æ–≤–∏–π */
      --off: #ffffff;  /* –±—ñ–ª–∏–π */
      --text: #000;
      --btn-bg: #f3f3f3;
      --btn-border: #bbb;
      --btn-active: #40e0d0;
    }
    * { box-sizing: border-box; }
    html, body, .wrap, .panel, canvas, .toolbar, .toolbar button {
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    body {
      margin: 0;
      font-family: Verdana, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap {
      display: flex;
      gap: 16px;
      align-items: flex-start;
      max-width: calc( (var(--cell) * 6) + var(--panel-w) + 40px );
      margin: 20px auto;
      padding: 0 12px;
    }
    .stage { position: relative; width: fit-content; }
    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 0 0 8px;
      align-items: center;
    }
    .toolbar button {
      appearance: none;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      padding: 10px 14px;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      min-width: 80px;
      box-shadow: 0 1px 0 rgba(0,0,0,.06);
    }
    .toolbar button:active { transform: translateY(1px); }
    .toolbar button.active {
      border-color: #2aaea0;
      background: #e7fbf8;
      outline: 2px solid var(--btn-active);
    }

    canvas { display: block; background: #ddd; border: 1px solid #000; }

    .panel {
      width: var(--panel-w);
      background: var(--panel-bg);
      border: 1px solid #aaa;
      border-radius: 8px;
      padding: 12px 12px 16px;
      position: sticky;
      top: 12px;
    }
    .panel h3 { margin: 0 0 10px; font-size: 18px; }
    .row { margin: 10px 0; font-size: 18px; }
    .hint-title { margin-top: 18px; font-size: 16px; }
    .hint-line { font-size: 14px; word-break: break-word; opacity: .95; }

    .footer {
      text-align: center;
      margin-top: 8px;
      font-size: 18px;
      font-weight: 600;
      color: #fff;
      text-shadow:
        0 0 3px #000, 1px 0 #000, -1px 0 #000, 0 1px #000, 0 -1px #000;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <!-- –ï–∫—Ä–∞–Ω–Ω—ñ –∫–Ω–æ–ø–∫–∏ –∑–≤–µ—Ä—Ö—É -->
      <div class="toolbar" id="toolbar">
        <button type="button" id="btnRestart" title="–†–µ—Å—Ç–∞—Ä—Ç (R)">‚ü≤ –†–µ—Å—Ç–∞—Ä—Ç</button>
        <button type="button" class="btnGrid" data-rows="3" data-cols="4" title="3√ó4 (–∫–ª–∞–≤—ñ—à–∞ 1)">3√ó4</button>
        <button type="button" class="btnGrid" data-rows="4" data-cols="4" title="4√ó4 (–∫–ª–∞–≤—ñ—à–∞ 2)">4√ó4</button>
        <button type="button" class="btnGrid" data-rows="5" data-cols="5" title="5√ó5 (–∫–ª–∞–≤—ñ—à–∞ 3)">5√ó5</button>
        <button type="button" id="btnHint" title="–í–∏–∫–æ–Ω–∞—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –∫—Ä–æ–∫ –ø—ñ–¥–∫–∞–∑–∫–∏">üí° –ü—ñ–¥–∫–∞–∑–∫–∞: —Ö—ñ–¥</button>
      </div>

      <!-- —à–∏—Ä–∏–Ω–∞/–≤–∏—Å–æ—Ç–∞ –∫–∞–Ω–≤–∞—Å–∞ –æ–Ω–æ–≤–ª—é—é—Ç—å—Å—è —Å–∫—Ä–∏–ø—Ç–æ–º –ø—Ä–∏ –∑–º—ñ–Ω—ñ rows/cols -->
      <canvas id="game" width="400" height="360" aria-label="–°–≤—ñ—Ç–ª–æ—Ç–∏—Ü—è–ª–∫–∞"></canvas>
    </div>

    <aside class="panel">
      <h3>–ü–∞–Ω–µ–ª—å</h3>
      <div class="row" id="shuffleInfo">–ó–∞–ø–ª—É—Ç–∞–Ω–æ –∑–∞ 0 –∫—Ä–æ–∫—ñ–≤</div>
      <div class="row" id="stepsInfo">–ö—Ä–æ–∫–∏: 0</div>
      <div class="row" id="timeInfo">–ß–∞—Å: 0 —Å</div>

      <div class="hint-title">–ü—ñ–¥–∫–∞–∑–∫–∞ (–∑–∞–ª–∏—à–∏–ª–æ—Å—å):</div>
      <div class="hint-line" id="hintLine1"></div>
      <div class="hint-line" id="hintLine2"></div>

      <hr style="margin:16px 0;">
      <div style="font-size:14px; line-height:1.35; opacity:.85">
        –ö–ª–∞–≤—ñ—à—ñ: <b>R</b> ‚Äî —Ä–µ—Å—Ç–∞—Ä—Ç, <b>1</b> ‚Äî 3√ó4, <b>2</b> ‚Äî 4√ó4, <b>3</b> ‚Äî 5√ó5. <br/>
        –ê–±–æ –∫–æ—Ä–∏—Å—Ç—É–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–∞–º–∏ –∑–≤–µ—Ä—Ö—É –ø–æ–ª—è.
      </div>
    </aside>
  </div>

  <div class="footer" id="restartFooter">–î–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ—ó –≥—Ä–∏ –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å R</div>

  <script>
    // ------------ –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏/—Å—Ç–∞–Ω ------------
    const CELL = 100;           // px
    const BOTTOM_PAD = 60;      // –º—ñ—Å—Ü–µ –ø—ñ–¥ –ø–æ–ª–µ–º –¥–ª—è —Ç–µ–∫—Å—Ç—É –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ –∫–∞–Ω–≤–∞—Å–∞
    let rows = 3, cols = 4;     // –¥–µ—Ñ–æ–ª—Ç–Ω–∞ —Å—ñ—Ç–∫–∞

    const COLORS = {
      on:  '#40e0d0',
      off: '#ffffff',
      grid:'#000000',
      text:'#000000'
    };

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const shuffleInfo = document.getElementById('shuffleInfo');
    const stepsInfo   = document.getElementById('stepsInfo');
    const timeInfo    = document.getElementById('timeInfo');
    const hintLine1   = document.getElementById('hintLine1');
    const hintLine2   = document.getElementById('hintLine2');

    const toolbar     = document.getElementById('toolbar');
    const btnRestart  = document.getElementById('btnRestart');
    const btnHint     = document.getElementById('btnHint');

    let grid = [];           // true = –±—ñ—Ä—é–∑–æ–≤–∞, false = –±—ñ–ª–∞
    let stepCount = 0;
    let startTime = 0;
    let timerId = null;
    let gameWon = false;
    let winTime = 0;

    let shuffleHistory = [];  // —ñ—Å—Ç–æ—Ä—ñ—è –Ω–∞—Ç–∏—Å–∫–∞–Ω—å –ø—ñ–¥ —á–∞—Å –∑–∞–ø–ª—É—Ç—É–≤–∞–Ω–Ω—è
    let solutionHint = [];    // –æ–±–µ—Ä–Ω–µ–Ω–∏–π —Å–ø–∏—Å–æ–∫ (–ø—ñ–¥–∫–∞–∑–∫–∞ –¥–æ —Ä–æ–∑–≤'—è–∑–∞–Ω–Ω—è)
    let hintIndex = 0;        // –≤–∫–∞–∑—ñ–≤–Ω–∏–∫ –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –∫—Ä–æ–∫ –ø—ñ–¥–∫–∞–∑–∫–∏

    // ------------ –£—Ç–∏–ª—ñ—Ç–∏ ------------
    function resizeCanvas() {
      canvas.width  = cols * CELL;
      canvas.height = rows * CELL + BOTTOM_PAD;
    }

    function cellIndex(r, c) {
      // –Ω—É–º–µ—Ä–∞—Ü—ñ—è –∫–ª—ñ—Ç–∏–Ω–æ–∫: 1..(rows*cols), —Ä—è–¥–æ–∫ –∑–∞ —Ä—è–¥–∫–æ–º
      return r * cols + c + 1;
    }

    function indexToRC(idx1) {
      // –∑ –Ω–æ–º–µ—Ä–∞ 1..N –¥–æ (r, c)
      const z = idx1 - 1;
      return { r: Math.floor(z / cols), c: z % cols };
    }

    function toggleNeighbors(r, c) {
      const dirs = [[0,0],[0,1],[0,-1],[1,0],[-1,0]];
      for (const [dr, dc] of dirs) {
        const nr = r + dr, nc = c + dc;
        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
          grid[nr][nc] = !grid[nr][nc];
        }
      }
    }

    function allSameColor() {
      const first = grid[0][0];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (grid[r][c] !== first) return false;
        }
      }
      return true;
    }

    function startTimer() {
      stopTimer();
      startTime = performance.now();
      timerId = setInterval(updatePanel, 200);
    }
    function stopTimer() {
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }
    }

    function randInt(a, b) { // –≤–∫–ª—é—á–Ω–æ [a, b]
      return Math.floor(Math.random() * (b - a + 1)) + a;
    }

    // ------------ –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Ä–æ–∑–≤‚Äô—è–∑–Ω–æ—ó –ø–æ–∑–∏—Ü—ñ—ó ------------
    function generateSolvablePosition() {
      // 1) –≤—Å—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏ ON
      grid = Array.from({length: rows}, () => Array.from({length: cols}, () => true));

      // 2) –≤–∏–ø–∞–¥–∫–æ–≤–µ "–∑–∞–ø–ª—É—Ç—É–≤–∞–Ω–Ω—è"
      const numMoves = randInt(5, 14);
      shuffleHistory = [];
      for (let i = 0; i < numMoves; i++) {
        const r = randInt(0, rows - 1);
        const c = randInt(0, cols - 1);
        toggleNeighbors(r, c);
        shuffleHistory.push(cellIndex(r, c));
      }

      // 3) –ü—ñ–¥–∫–∞–∑–∫–∞ ‚Äî —Ü–µ –æ–±–µ—Ä–Ω–µ–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ –∑–∞–ø–ª—É—Ç—É–≤–∞–Ω–Ω—è
      solutionHint = [...shuffleHistory].reverse();
      hintIndex = 0; // —Å–∫–∏–¥–∞—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫ –ø—ñ–¥–∫–∞–∑–æ–∫

      // –û–Ω–æ–≤–∏—Ç–∏ –ø–∞–Ω–µ–ª—å
      shuffleInfo.textContent = `–ó–∞–ø–ª—É—Ç–∞–Ω–æ –∑–∞ ${numMoves} –∫—Ä–æ–∫—ñ–≤`;
      renderHints();
    }

    function renderHints() {
      // –∑–∞–ª–∏—à–æ–∫ –ø—ñ–¥–∫–∞–∑–æ–∫, –ø–æ—á–∏–Ω–∞—é—á–∏ –∑ –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∫—Ä–æ–∫—É
      const remaining = solutionHint.slice(hintIndex);
      if (remaining.length > 7) {
        hintLine1.textContent = remaining.slice(0, 7).join(' > ');
        hintLine2.textContent = remaining.slice(7).join(' > ');
      } else {
        hintLine1.textContent = remaining.join(' > ');
        hintLine2.textContent = '';
      }
    }

    // ------------ –†–µ–Ω–¥–µ—Ä ------------
    function drawOutlinedText(text, x, y) {
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 4;
      ctx.strokeText(text, x, y);
      ctx.fillText(text, x, y);
      ctx.restore();
    }

    function draw() {
      // —Ñ–æ–Ω –ø–æ–ª—è
      ctx.fillStyle = '#dcdcdc';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // –∫–ª—ñ—Ç–∏–Ω–∫–∏
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '16px Verdana';

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          ctx.fillStyle = grid[r][c] ? COLORS.on : COLORS.off;
          ctx.fillRect(c * CELL, r * CELL, CELL, CELL);

          // —Ä–∞–º–∫–∞
          ctx.strokeStyle = COLORS.grid;
          ctx.lineWidth = 2;
          ctx.strokeRect(c * CELL, r * CELL, CELL, CELL);

          // –Ω–æ–º–µ—Ä –∫–ª—ñ—Ç–∏–Ω–∫–∏
          ctx.fillStyle = COLORS.text;
          const num = cellIndex(r, c);
          ctx.fillText(String(num), c * CELL + CELL / 2, r * CELL + CELL / 2);
        }
      }

      // –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –ø–µ—Ä–µ–º–æ–≥—É –ø—ñ–¥ –ø–æ–ª–µ–º (–ø–æ —Ü–µ–Ω—Ç—Ä—É –≤—ñ–¥–Ω–æ—Å–Ω–æ –ø–æ–ª—è)
      if (gameWon) {
        const msg = `–ü–µ—Ä–µ–º–æ–≥–∞! –ß–∞—Å: ${winTime} —Å`;
        ctx.font = '20px Verdana';
        drawOutlinedText(msg, (cols * CELL) / 2, rows * CELL + 20);
      }
    }

    function updatePanel() {
      // –∫—Ä–æ–∫–∏
      stepsInfo.textContent = `–ö—Ä–æ–∫–∏: ${stepCount}`;
      // —á–∞—Å
      const sec = gameWon ? winTime : Math.floor((performance.now() - startTime) / 1000);
      timeInfo.textContent = `–ß–∞—Å: ${sec} —Å`;

      draw();
    }

    // ------------ –í–∑–∞—î–º–æ–¥—ñ—è: Pointer Events ------------
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    canvas.style.touchAction = 'manipulation';

    function canvasPosToCell(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      if (y > rows * CELL) return null; // —ñ–≥–Ω–æ—Ä—É—î–º–æ –∫–ª—ñ–∫–∏ –ø—ñ–¥ –ø–æ–ª–µ–º
      const c = Math.floor(x / CELL);
      const r = Math.floor(y / CELL);
      if (r < 0 || r >= rows || c < 0 || c >= cols) return null;
      return { r, c };
    }

    function handleTapEvent(e) {
      if (gameWon) return;
      const cell = canvasPosToCell(e.clientX, e.clientY);
      if (!cell) return;

      toggleNeighbors(cell.r, cell.c);
      stepCount++;

      if (allSameColor()) {
        gameWon = true;
        winTime = Math.floor((performance.now() - startTime) / 1000);
        stopTimer();
      }
      renderHints(); // –ø—Ä–∏ —Ä—É—á–Ω–∏—Ö –∫–ª—ñ–∫–∞—Ö –ª–∏—à–∞—î–º–æ –ø—ñ–¥–∫–∞–∑–∫—É —è–∫ –∑–∞–ª–∏—à–æ–∫ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–æ—ó –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ
      updatePanel();
    }

    canvas.addEventListener('pointerdown', (e) => {
      // –ª–∏—à–µ –ø–µ—Ä–≤–∏–Ω–Ω–∞ –∫–Ω–æ–ø–∫–∞ (–ª—ñ–≤–∞ –º–∏—à–∞) –∞–±–æ –¥–æ—Ç–∏–∫
      if (e.pointerType === 'mouse' && e.button !== 0) return;
      e.preventDefault(); // –±–ª–æ–∫—É—î —Å–∏–Ω—Ç–µ—Ç–∏—á–Ω–∏–π click –ø—ñ—Å–ª—è touch
      handleTapEvent(e);
    });

    // ------------ –ö–Ω–æ–ø–∫–∏ —É —Ç—É–ª–±–∞—Ä—ñ (Pointer Events) ------------
    toolbar.addEventListener('pointerdown', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      e.preventDefault();

      if (btn.id === 'btnRestart') {
        newGame(rows, cols);
        return;
      }

      if (btn.id === 'btnHint') {
        performHintStep();
        return;
      }

      if (btn.classList.contains('btnGrid')) {
        const r = parseInt(btn.dataset.rows, 10);
        const c = parseInt(btn.dataset.cols, 10);
        newGame(r, c);
        updateActiveGridButtons(r, c);
      }
    });

    function performHintStep() {
      if (gameWon) return;
      if (hintIndex >= solutionHint.length) return; // –ø—ñ–¥–∫–∞–∑–∫–∏ –∑–∞–∫—ñ–Ω—á–∏–ª–∏—Å—å

      const nextIdx = solutionHint[hintIndex]; // –Ω–æ–º–µ—Ä –∫–ª—ñ—Ç–∏–Ω–∫–∏ (1..N)
      const { r, c } = indexToRC(nextIdx);

      toggleNeighbors(r, c);
      stepCount++;
      hintIndex++;         // –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –∫—Ä–æ–∫—É –ø—ñ–¥–∫–∞–∑–∫–∏
      renderHints();

      if (allSameColor()) {
        gameWon = true;
        winTime = Math.floor((performance.now() - startTime) / 1000);
        stopTimer();
      }
      updatePanel();
    }

    function updateActiveGridButtons(r, c) {
      document.querySelectorAll('.btnGrid').forEach(b => b.classList.remove('active'));
      const sel = `.btnGrid[data-rows="${r}"][data-cols="${c}"]`;
      const active = document.querySelector(sel);
      if (active) active.classList.add('active');
    }

    // ------------ –ö–ª–∞–≤—ñ—à—ñ (–∑–∞–ª–∏—à–∞—î–º–æ —Ç–µ–∂) ------------
    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        newGame(rows, cols);
      } else if (e.key === '1') {
        newGame(3, 4); updateActiveGridButtons(3,4);
      } else if (e.key === '2') {
        newGame(4, 4); updateActiveGridButtons(4,4);
      } else if (e.key === '3') {
        newGame(5, 5); updateActiveGridButtons(5,5);
      } else if (e.key === 'h' || e.key === 'H') {
        // –≥–∞—Ä—è—á–∞ –∫–ª–∞–≤—ñ—à–∞ –Ω–∞ –ø—ñ–¥–∫–∞–∑–∫—É (–æ–ø—Ü—ñ–π–Ω–æ)
        performHintStep();
      }
    });

    // ------------ –ñ–∏—Ç—Ç—î–≤–∏–π —Ü–∏–∫–ª ------------
    function newGame(r, c) {
      rows = r; cols = c;
      resizeCanvas();
      generateSolvablePosition();
      stepCount = 0;
      gameWon = false;
      winTime = 0;
      startTimer();
      updatePanel();
    }

    // —Å—Ç–∞—Ä—Ç
    newGame(rows, cols);
    updateActiveGridButtons(rows, cols);
  </script>
</body>
</html>
